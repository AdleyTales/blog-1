# 常用前端构建工具介绍

构建工具的主要功能就是实现自动化处理，例如对代码进行检查、预编译、合并、压缩；生成雪碧图、sourceMap、版本管理；运行单元测试、监控等，当然有的工具还提供模块化、组件化的开发流程功能。

网上各类的构建工具非常多，有家喻户晓的 Grunt、Gulp、Webpack，也有各大公司团队开源的构建工具，这里通过 Github 的 Star 数量来简单的对比下各个工具的流行度：

截止2018年12月17日数据：

![stars](./assets/stars.png)

* [webpack](https://github.com/webpack/webpack) star: 45848
* [gulp](https://github.com/gulpjs/gulp) star: 30698
* [Parcel](https://github.com/parcel-bundler/parcel) star: 28580
* [rollup](https://github.com/rollup/rollup) star: 14345
* [browserify](https://github.com/browserify/browserify) star: 12371
* [grunt](https://github.com/gruntjs/grunt) star: 11899
* [Yeoman](https://github.com/yeoman/yeoman) star: 9124
* [WeFlow](https://github.com/Tencent/WeFlow) star: 3013 腾讯
* [FIS3](https://github.com/fex-team/fis3) star: 2527
* [cooking](https://github.com/ElemeFE/cooking) star: 1860
* [jdf](https://github.com/putaoshu/jdf) star: 596


## 前端构建工具

如果把工具按类型分，可以分为这三类：

* 基于任务运行的工具：
Grunt、Gulp
它们会自动执行指定的任务，就像流水线，把资源放上去然后通过不同插件进行加工，它们包含活跃的社区，丰富的插件，能方便的打造各种工作流。

* 基于模块化打包的工具：
Browserify、Webpack、rollup.js
有过 Node.js 开发经历的应该对模块很熟悉，需要引用组件直接一个 require  就 OK，这类工具就是这个模式，还可以实现按需加载、异步加载模块。

* 整合型工具：
Yeoman、FIS、jdf、Athena、cooking、weflow
使用了多种技术栈实现的脚手架工具，好处是即开即用，缺点就是它们约束了技术选型，并且学习成本相对较高。

下面简单介绍一下常用的前端构建工具

### webpack

Webpack处理文件的过程可以分为两个维度：文件间的关系和文件的内容。

* 文件间的关系处理，主要是通过文件和模块标记方法来实现；
* 文件内容的处理主要通过 `loaders` 和 `plugins` 来处理。

Webpack 是目前最热门的前端资源模块化管理和打包工具，还是先通过一张图大致了解它的运行方式：

![](./assets/what-is-webpack.png)

详细介绍见： [webpack入门](./webpack入门.md)

### Grunt

Grunt 是老牌的构建工具，特点是配置驱动，你需要做的就是了解各种插件的功能，然后把配置整合到 Gruntfile.js 中，可以看下面的配置例子，简单直接：

```
module.exports = function(grunt) {
  grunt.initConfig({
    jshint: {
      files: ['Gruntfile.js', 'src/**/*.js', 'test/**/*.js'],
      options: {
        globals: {
          jQuery: true
        }
      }
    },
    watch: {
      files: ['<%= jshint.files %>'],
      tasks: ['jshint']
    }
  });

  grunt.loadNpmTasks('grunt-contrib-jshint');
  grunt.loadNpmTasks('grunt-contrib-watch');

  grunt.registerTask('default', ['jshint']);
};
```

Grunt 缺点也是配置驱动，当任务非常多的情况下，试图用配置完成所有事简直就是个灾难；再就是它的 I/O 操作也是个弊病，它的每一次任务都需要从磁盘中读取文件，处理完后再写入到磁盘，例如：我想对多个 less 进行预编译、压缩操作，那么 Grunt 的操作就是：

> 读取 less 文件 -> 编译成 css -> 存储到磁盘 -> 读取 css -> 压缩处理 -> 存储到磁盘

这样一来当资源文件较多，任务较复杂的时候性能就是个问题了。

### gulp

Gulp 特点是代码驱动，写任务就和写普通的 Node.js 代码一样：

```
var gulp = require('gulp');
var pug = require('gulp-pug');
var less = require('gulp-less');
var minifyCSS = require('gulp-csso');

gulp.task('html', function(){
  return gulp.src('client/templates/*.pug')
    .pipe(pug())
    .pipe(gulp.dest('build/html'))
});

gulp.task('css', function(){
  return gulp.src('client/templates/*.less')
    .pipe(less())
    .pipe(minifyCSS())
    .pipe(gulp.dest('build/css'))
});

gulp.task('default', [ 'html', 'css' ]);
```

再一个对文件读取是流式操作（Stream），也就是说一次 I/O 可以处理多个任务，还是 less 的例子，Gulp 的流程就是：

> 读取 less 文件 -> 编译成 css -> 压缩处理 -> 存储到磁盘

Gulp 作为任务类型的工具没有明显的缺点，唯一的问题可能就是完成相同的任务它需要写的代码更多一些，所以除非是项目有历史包袱（原有项目就是基于 Grunt 构建）在 Grunt 与 Gulp 对比看来还是比较推荐 Gulp！

适用场景：

通过上面的介绍可以看出它们侧重对整个过程的控制管理，实现简单、对架构无要求、不改变开发模式，所以非常适合前端、小型、需要快速启动的项目。

### Parcel

Parcel 是 Web 应用打包工具，适用于经验不同的开发者。它利用多核处理提供了极快的速度，并且不需要任何配置。

Parcel 可以使用任何类型的文件作为入口，但是最好还是使用 HTML 或 JavaScript 文件。如果在 HTML 中使用相对路径引入主要的 JavaScript 文件，Parcel 也将会对它进行处理将其替换为相对于输出文件的 URL 地址。

![](./assets/parcel.png)

基于一个合理大小的应用，包含1726个模块，6.5M 未压缩大小。在一台有4个物理核心 CPU 的 2016 MacBook Pro 上构建。

|打包工具|时间|
| --- | ---|
|browserify|22.98s|
|webpack|20.71s|
|parcel|9.98s|
|parcel - with cache|2.64s|

[Parcel使用文档](https://parceljs.org/getting_started.html)

### FIS

FIS是百度出的一套前端工程构建工具，目的是解决前端开发中自动化工具、性能优化、模块化框架、开发规范、代码部署、开发流程等问题。

目前最新版本是 FIS3，它的定位不仅是Task管理工具，其核心思想在于整站强大的静态资源管理能力。

无论是按需加载、组件内嵌、BigRender、Quickling等方案都能快速实施。

FIS的本质是基于`静态资源标记+动态解析静态资源表`。

在模板、js里，使用特殊的标记方法引用前端资源，构建的时候生成一张资源依赖表，浏览器或者后端模板语言在解析的过程中通过查表得到某个静态资源在不同环境下的引用路径。

所以不管是纯前端渲染（标记方法已经转换成浏览器能识别的了）还是后端（php、node、java）渲染，都很容易支持到。

这样可以做到非常精细化的控制资源的按需加载。

可以说fis真正做到了静态资源动态按需加载。

## 构建工具选型

其实，在做选型的时候，我们往往会考虑以下几个因素：

* 是否符合团队的技术栈
* 是否符合项目需求
* 生态圈是否完善、社区是否活跃

webpack刚出现时，gulp如日中天，现在webpack更新到4.x版本，gulp却逐渐淡出我们的视线，仿佛webpack已经成为了打包器的事实标准。

###  WebPack 和 Grunt 以及 Gulp 相比有什么特性

其实Webpack和另外两个并没有太多的可比性：Gulp/Grunt是一种能够优化前端的开发流程的工具，而WebPack是一种模块化的解决方案，不过Webpack的优点使得Webpack可以替代Gulp/Grunt类的工具。

Grunt和Gulp的工作方式是：在一个配置文件中，指明对某些文件进行类似编译，组合，压缩等任务的具体步骤，这个工具之后可以自动替你完成这些任务。

Webpack的工作方式是：把你的项目当做一个整体，通过一个给定的主文件（如：index.js），Webpack将从这个文件开始找到你的项目的所有依赖文件，使用loaders处理它们，最后打包为一个浏览器可识别的JavaScript文件。

gulp是基于流的构建工具：all in one的打包模式，输出一个js文件和一个css文件，优点是减少http请求，万金油方案。

webpack是模块化管理工具，使用webpack可以对模块进行压缩、预处理、打包、按需加载等。

既然gulp被webpack反杀了，一定是有不如人的地方。

以gulp为代表的传统打包最大的问题是解决不了按需打包，就更别说按需加载了。

因为传统的打包思路是`遍历源文件 => 匹配规则 => 打包/处理`，也就是说只要被规则命中了，即便是程序用不到的模块也会被无脑打包。

根本原因是按需这个事无法被规则描述，只能被程序逻辑描述。

### Webpack 和 FIS/FIS3

其实在webpack之前不是没有解决方案，百度fis最得意的地方就是解决了这个问题，并且是理论上堪称完美的解决方案。

可以说，fis/fis3是grunt、gulp之后，兴起的一个比较优秀的前端工程解决方案。

单从原理上来讲，fis比webpack要先进好多好多。

但是 fis 最大的缺点是需要后端配合，后端通常不太配合这种需求，百度fis也就不了了之了。

同时，fis先进的理念也成为它的一个缺陷，就是自定义的一套标记语言，大量自定义的资源标记语法并不能被浏览器直接接解析或者被社区流行的工具（browserify/babel）转换。

比如fis依赖自家定制的mod.js来解析`require()`函数（即定位资源）以及资源base64内嵌语法`__include()`等。这一点直接导致了fis无法和后来的强大的npm社区对接，大量的npm前端模块在fis用不了。

即使后来的 fis3 没有了需要后端配合的限制，标记方法已经转换成浏览器能识别的，但是已经错过了发展最快的时代。

没有丰富的 Pligins ，估计是目前各公司在选择前端统一的构建工具标准时，不考虑fis的最大原因。

那webpack是怎么解决按需问题的呢？

前面说了，按需只能被程序逻辑描述，webpack的打包思路就是从程序逻辑入手：`入口文件 => 分析代码 => 找出依赖 => 打包`。

这样代码里不出现的模块就不可能被打进包里，甚至还可以实现按需加载，这就是webpack最有价值的地方。

打包过程中还有一个仅次于按需的需求，那就是分包。

之所以说webpack或者说所有的打包器都特别适合SPA应用，是因为SPA只有一个入口，基本不需要分包或者分包需求很简单。

但在网站类应用上，我们讨论的不是要不要分包，而是怎样最不浪费的分包，将加载总量降到最低。

这个通常来说不是大问题，只要配合好文件目录结构的划分，多数分包需求都可以用规则描述。

这方面webpack更进了一步，可以在业务代码中依托特定的语法标记出需要分包的模块，这就使分包的实现能在一定程度上自动化了。

fis的作者曾经说过，webpack只差一步——生成支持静态资源表，就完美了，深以为然。

目前，webpack好像有生成sourcemap的插件，但是缺少配套的解析sourcemap的工具，后端的模板引擎貌似也没有支持sourcemap。

webpack现有的懒加载手段不完美，但是基本够用，主要是它直接支持commonjs规范的require语法，再配置babel等还可以直接解析ES6语法，加上可以直接使用npm模块这一点，依托npm社区强大红利来搭建公司级公共组件化规范。

所以综合考虑，webpack目前是前端构建工具的首选。

## 参考

* [Web Bundler CheatSheet, 选择合适的构建打包工具](https://zhuanlan.zhihu.com/p/37267736)
* [前端工程化——构建工具选型](https://www.jianshu.com/p/3e8941eda2dd)
* [Webpack是答案吗](http://refined-x.com/2017/06/16/Webpack%E6%98%AF%E7%AD%94%E6%A1%88%E5%90%97/)